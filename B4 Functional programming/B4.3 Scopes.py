# ***** Области видимости *****
# В Python существует 3 области видимости:
#     Локальная
#     Глобальная
#     Нелокальная (добавлена в Python 3)

# *** Локальная область видимости ***
print("Локальная область")
# переменные, определяемые внутри инструкции def, видны только программному коду внутри инструкции def.
# К этим именам нельзя обратиться за пределами функции.
# То есть переменные внутри функций находятся внутри локальной области видимости.

# Имена, определяемые внутри инструкции def, не вступают в конфликт с именами, находящимися за пределами
# инструкции def, даже если и там, и там присутствуют одинаковые имена переменных.

def local():
    x = 5
    print(x)

x = 10
local()  # выводим "локальную" переменную из функции
print(x)  # выводим "глобальную" переменную
print()

# !!! видимости переменной (где она может использоваться) всегда определяется местом, где ей было присвоено значение,
# и никакого отношения не имеет к месту, откуда была вызвана функция.

# *** Глобальная область видимости ***
print("Глобальная область")

def local_1():
    print(x)  # так как x нет в локальной области видимости, мы берем её из глобальной области

x = 10
local_1()
print(x)


# Каждый вызов функции создает новую локальную область видимости.
# По умолчанию все имена, которым присваиваются значения внутри функции, помещаются в локальную область видимости.
# Если необходимо присвоить значение имени верхнего уровня в модуле (глобальной переменной),
# это имя необходимо объявить внутри функции глобальным с помощью инструкции global.
# Пример:
x = 3


def func():
   global x  # объявляем, что переменная является глобальной
   print(x)
   x = 5
   x += 5
   return x


func()
print(x)
# !!!!! не нужно менять глобальные переменные внутри функции.
# Комьюнити Python объявило такую практику очень нежелательной,
# так как из-за этого исправление кода становится намного сложнее. !!!!!
print()

# *** Нелокальная область видимости ***
print("Нелокальная область")
# Появилось это понятие в Python 3 вместе с ключевым словом nonlocal.
# Логика его написания примерно такая же, как и у global.
# Но у nonlocal есть особенность.
# Nonlocal используется чаще всего во вложенных функциях, когда мы хотим дать интерпретатору понять,
# что для вложенной функции определенная переменная не является локальной,
# но она и не является глобальной в общем смысле.

def get_my_func():
    def hello_world():  # создаем функцию внутри функции
        print('Hello world!')
    return hello_world  # возвращаем функцию


hello_world_func = get_my_func()
print(type(hello_world_func))
hello_world_func()


def get_mul_func(m):
    nonlocal_m = m
    def local_mul(n):
        return n * nonlocal_m
    return local_mul


two_mul = get_mul_func(2)  # создали функцию, которая будет получать числа и умножать их на 2
print(two_mul(5))

# Переменная nonlocal_m по отношению к функции local_mul находится в неком промежуточном состоянии.
# Она и не глобальная, потому что объявлена не на уровне скрипта,
# но и не локальная по отношению к функции local_mul.
# Использование переменных объявленных вне функции называется замыканием функций.


# ***** Запакованные переменные, или что такое *args и **kwargs *****
# Для начала давайте разберемся с позиционными (positional) и именованными (keyword) аргументами.
# Из названий можно предположить, что одни аргументы зависят от позиции, а вторые от имени, всё логично.

# Важная особенность: все именованные аргументы должны идти строго после позиционных,
# как при объявлении функций, так и при их вызове.
# # Правильно
# func(a, b, c=3)
#
# # Неправильно
# func(a=1, b, c)

# Оператор * чаще всего ассоциируется с операцией умножения, но в Python он имеет и другой смысл.
# Этот оператор позволяет «распаковывать» (получить все значения из какой-либо последовательности,
# а не саму последовательность) объекты (например, списки или кортежи), внутри которых хранятся некие элементы.

# Не используя оператор распаковки, если мы захотим поместить список а в список b,
# мы просто укажем его в качестве одного из элементов нового списка.
# Но если мы захотим добавить именно значение из первого списка, а не сам список.
# То как раз оператор распаковки сделает это, то есть он вытащит из нашего списка все значения.

print("Без оператора распаковки")
a = [1, 2, 3]
b = [a, 4, 5, 6]
print(b)

print("С оператором распаковки")
b = [*a, 4, 5, 6]
print(b)

# То есть оператор распаковки позволяет работать со значением последовательности, а не с самой последовательностью.
# В первом случае функция print печатает список, а во втором все значения списка:
print(a)
print(*a)

# Чтобы функция могла принимать неограниченное количество позиционных аргументов,
# есть специальная конструкция *args, а для именованных аргументов **kwargs.
#
# Аrgs и kwargs не являются зарезервированными словами, это просто общее обозначение,
# args — это сокращение от «arguments» (аргументы),
# а kwargs — сокращение от «keyword arguments» (именованные аргументы).
#
# Важно, что они должны начинаться с одной и двух звездочек соответственно.
# Каждая из этих конструкций используется для распаковки аргументов соответствующего типа,
# позволяя вызывать функции со списком аргументов переменной длины, как в случае функции print.

# Чтобы правильно обрабатывать *args и **kwargs нужно представлять, чем они являются.
# А собственно args — это кортеж, а kwargs  — это словарь.


def my_func(*args, **kwargs):
    print(type(args))
    print(type(kwargs))

my_func()

#  сделаем функцию сумматор, которая будет складывать любое количество переданных ей аргументов.
def adder(*nums):
    sum_ = 0
    for n in nums:  # проходим по всем элементам кортежа
        sum_ += n

    return sum_


print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3
print(adder(1, 2, 3))  # 6
print()

print("Задание 4.3.2")
# Написать функцию, которая будет перемножать любое количество переданных ей аргументов.

def multiplication(*nums):
    res = 1
    for n in nums:
        res *= n
    return res


print(multiplication(1))
print(multiplication(1, 2))
print(multiplication(1, 2, 3))
print()

# *** Изменяемые типы данных как аргументы по умолчанию  ***
print("Изменяемые типы данных как аргументы по умолчанию ")
# Основная идея состоит в том, что функция должна вести себя одинаково на одних и тех же входных данных
# и выдавать результат, который соответствует этим входным данным.
# Это одна из основных идей функционального программирования,
# то есть такого стиля написания кода, где всё опирается на функции.

# Создадим неправильную функцию incorrect_func с указанием аргумента по умолчанию в виде списка.
# И вызовем эту функцию два раза.


def incorrect_func(name_arg=[]):
    print("Аргумент до изменения", name_arg)
    name_arg.append(1)
    print("Аргумент после изменения", name_arg)


incorrect_func()
print("-----")
incorrect_func()
print()
# Видим, что при одних и тех же входных данных функция выдает разные результаты,
# что в дальнейшей разработке может вводить в заблуждение.
# Если вдруг внутри функции нужно использовать списки, то этот момент можно обойти следующим образом:
# # установим аргумент name_arg пустым а внутри функции будем проверять его
print("корректная функция")
def correct_func(name_arg=None):
    if name_arg is None:
        name_arg = []
    print("Аргумент до изменения", name_arg)
    name_arg.append(1)
    print("Аргумент после изменения", name_arg)


# вызовем два раза одну и ту же функцию
correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])
print()
# Чтобы избежать такого, создадим функцию correct_func, где в качестве значения по умолчанию укажем значение None.
# А вот уже внутри функции будем проверять, если пользователь не поменял это значение,
# то будем инициализировать, например, пустой список.
# И тогда всё будет хорошо, при каждом вызове функции, если это необходимо,
# этот пустой список будет инициализироваться вместе со всеми остальными аргументами функции.


# *** Рекурсивные функции ***
print("Рекурсивные функции")
# Рекурсивная функция — это функция, вызывающая сама себя и обрабатывающая полученный результат до тех пор,
# пока не достигнем терминального условия (условия остановки).
# Количество раз, сколько функция вызвала сама себя, называется глубиной рекурсии.
print("Факториал числа")

def fact(n):
    """
    То есть три факториал — это два факториал умножить на три, и так далее.
    Остановимся мы в том случае, когда дойдем до единицы.
    Это значение мы знаем без вычисления, поэтому оно и будет терминальным условием,
    то есть той самой отправной точкой, где закончится наша рекурсия, и начнутся вычисления.
    """
    if n == 1:  # терминальный случай
        return 1
    return n * fact(n-1)  # рекурсивный вызов функции
print(fact(5))
print()

print("Числа Фибоначчи")
"""
последовательность Фибоначчи начинается с 1 и 1, после чего 
каждое новое число является результатом сложения двух предыдущих чисел. 
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
"""
def rec_fib(n):
    if n == 1:
        return 1
    if n == 2:
        return 1
    return rec_fib(n-1) + rec_fib(n-2)

print(rec_fib(10))

print("Задание 4.3.3")
# С помощью рекурсивной функции найдите сумму чисел от 1 до n.
def get_sum_of_numbers(n):
    if n == 1:
        return 1
    return n + get_sum_of_numbers(n-1)


print(get_sum_of_numbers(5))

print("Задание 4.3.4")
# С помощью рекурсивной функции развернуть строку.
def reverse_str(string):
    if len(string) == 0:
        return ''
    else:
        print(string[-1] + reverse_str(string[:-1]))
        return string[-1] + reverse_str(string[:-1])


print(reverse_str('test'))
print()

print("Задание 4.3.5")
# Дано натуральное число N. Вычислите сумму его цифр.
# При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется).


def sum_num(n):
    if n == 0:
        return n
    return n % 10 + sum_num(n // 10)


print(sum_num(123))

# решение от SkillFactory
# def sum_digit(n):
#    if n < 10:
#        return n
#    else:
#        return n % 10 + sum_digit(n // 10)