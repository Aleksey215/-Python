# ***** Итераторы и генераторы, оператор yield *****

print("*** Функции-генераторы ***")
# Их задача выполнять те действия, которые прописаны в теле функции-генератора,
# дальше уходить в «спячку» и ждать следующего вашего обращения.

# Такой процесс выполнения называют ещё «ленивыми вычислениями»,
# то есть вычислениями только в момент обращения, а не всего сразу, как это делают обычные функции.

# Синтаксис функций-генераторов отличается от обычных функции только оператором yield,
# он используется вместо оператора return.
# В обычной функции, когда интерпретатор встречает в теле функции оператор return,
# то он выходит из тела функции и возвращается к основной программе.
# Встречая же yield, он понимает, что функцию-генератор, закрывать не нужно,
# а нужно приостановить и затем вернуться к ней.


def fib():  # объявляем функцию генератор
    a, b = 0, 1  # объявляем первые два числа фибоначчи
    yield a  # возвращаем а
    yield b  # возвращаем b
    # при этом выполнение функции прервано не будет.

    # переходим в бесконечный цикл, который будет возвращать нам новое число Фибоначчи,
    # когда мы будем обращаться к генератору.
    while True:
        a, b = b, a + b
        yield b


# Чтобы получить значения из функции-генератора, можно воспользоваться циклом for:
# for num in fib():
#     print(num)
print()

print("Задание 4.4.1")
# Создать функцию-генератор, возвращающую бесконечную последовательность натуральных чисел.
# По умолчанию, она начинается с единицы и шагом 1, но пользователь может указать любой шаг
# и любое число в качестве аргумента функции, с которого будет начинаться последовательность.


def gen_num(start=1, step=1):
    c = start
    while True:
        yield c
        c += step


# for num in gen_num():
#     print(num)
print()

print("Задание 4.4.2")
# Создайте генератор, который по переданному списку создаёт последовательность,
# в которой элементы этого списка бесконечно циклично повторяются.
# Например, для списка [1, 2, 3] генератор создаст бесконечную последовательность
# 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, ... .
print("Мое решение")


def gen_list(my_list=None):
    if my_list is None:
        my_list = []
    c = 0
    while c != 3:
        for element in my_list:
            yield element
        c += 1

for el in gen_list([1,2,3]):
    print(el)
print("--------------------------")

print("Решение SkillFactory")


def repeat_list(list_):
   list_values = list_.copy()
   c = 0
   while c != 10:
       value = list_values.pop(0)
       list_values.append(value)
       c += 1
       yield value


for i in repeat_list([1, 2, 3]):
   print(i)
print("--------------------------")
print()

print("Итераторы")
# Итератор (iterator) — это объект, который возвращает свои элементы по одному за раз.
# В качестве итератора могут выступать следующие объекты:
# функции-генераторы;
# последовательности после проведения над ними некоторых операций.

# Если вы не знаете, является ли объект итерируемым,
# можно использовать функцию iter(object) и передать ей в качестве аргумента объект для проверки.

print(iter([1,2,3]))

# Системная функция next() позволяет получить следующий элемент от итератора.
# Механизм взаимодействия с итераторами такой:
# 1. Сначала получить итератор от итерируемого объекта
#    (объекта, для которого разработан итератор вами или другими разработчиками).

# 2. Потом несколько раз обращаемся к итератору и получаем элементы последовательности
#    с помощью функции next().

# Логика работы с итераторами в языке Python следующая:
# 1. Получаем итератор с помощью функции iter(iterable_object).
# 2. Вызываем много раз next(iterator) от полученного итератора.
# 3. Когда получим ошибку StopIteration — прекращаем работу.
# Пример:
string = "my_string"  # создали строку
string_iter = iter(string)  # превратили ее в итератор
# проверка типа
print(type(string))
print(type(string_iter))
# получение элементов итератора:
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
print(next(string_iter))
# После того, как элементы закончились, если мы попытаемся получить ещё один элемент,
# то получим соответствующую ошибку
print()

print("извлечение элементов из генераторов")
# Функции генераторы - это тоже итераторы
# можно получить их элементы, так:


def gen_num1(start=1, step=1):
    c = start
    while True:
        yield c
        c += step


my_gen_func = gen_num1(50, 5)
for i in range(10):
    print(next(my_gen_func))