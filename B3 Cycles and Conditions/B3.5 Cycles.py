# ***** Cycles *****
# ***** Цикл for *****
# циклы позволяют выполнять повторяющиеся действия, описанные в их теле.
# Тело цикла — набор команд, находящихся на одном и более отступе от отступа самого цикла.
# Другими словами, тело цикла — это те команды, которые находятся внутри него и будут повторяться.

# Чтобы работать с циклом for, используется следующая конструкция:
# for value in itrator:
    # Начало блока кода с телом цикла
    # ...
    # ...
    # ...
    # Конец блока кода с телом цикла
# Код который будет выполняться после цикла

# В данном случае мы объявляем переменную value (название переменной вы выбираете сами),
# которая будет использоваться для того, чтобы по порядку получать значения из любого итерируемого объекта
# iterator (списка, кортежа, словаря, строки, и т. д.).
# Объект-итератор реализован таким образом, что позволяет получить доступ к следующему элементу в последовательности.

# !!! В отличие от многих других языков программирования, где для цикла for нужно использовать условие для остановки,
# в Python число шагов цикла ограничено длиной последовательности.
for i in [1, 2, 3, 4, 5]:
    print(i)
print("Пример 1.")
# Условие задачи: Найти сумму всех натуральных чисел от 1 до N включительно.

# Для начала нам нужно завести переменную, куда мы будем с вами суммировать все числа, пусть это будет переменная S.
# Где нам взять последовательность чисел от 1 до N включительно?
# Для это есть функция range(), которая как раз сделает последовательность нужных нам чисел.
# Функция range может работать тремя способами:
#         range(END);
#         range(START, END);
#         range(START, END, STEP).
# В первом случае она принимает одну переменную END
# и возвращает последовательность элементов от 0 до END-1 шагом в 1.
print(list(range(5)))
# из-за того, что нумерацию в программировании принято считать с нуля, правая граница последовательности не включается.
# Вернемся к нашей задаче, нас интересуют числа от 1 до N включительно, значит, код будет выглядеть следующим образом:
S = 0  # заводим переменную счетчик, в которой мы будем считать сумму
N = 5

# заводим цикл for в котором мы будем проходить по всем числам от одного до N
for i in range(1, N + 1):  # равносильно выражению for i in [1, 2, 3, ... , N -1, N]:
    print("Значение суммы на предыдущем шаге: ", S)
    print("Текущее число: ", i)
    S = S + i  # cуммируем текущее число i и перезаписываем значение суммы
    print("Значение суммы после сложения: ", S)
    print("----------------------------------------")
print("Конец цикла")
print()
print("Ответ: сумма равна = ", S)

print("Лесенка звездочек")
n = 5

for i in range(1, n + 1):
    print('*' * i)

print()
# ***** Цикл while *****
print("Цикл while")
# Цикл while подразумевает под собой немного другой подход к ограничению количества шагов, которые должны выполняться.
# Он выполняется до тех пор, пока истинно его условие.
# Как только оно становится ложным, цикл прерывается.
# Для компьютера это выглядит как: «Делай, пока не наступит ...» .
# Такой цикл ещё называют циклом с предусловием.

# while условие:
#     # Начало блока кода с телом цикла
#     # пока условие истинно, цикл выполняется
#     ...
#     ...
#     ...
#     # Конец блока кода с телом цикла
# # Код который будет выполняться после цикла

print()
# Пример 2.
print("Пример 2")
# Условие задачи: Написать цикл, который будет складывать натуральные числа, пока их сумма не превысит 500.
# Заранее мы не знаем число шагов нашего цикла, но знаем условие, при котором нужно остановиться.
# Поэтому выбираем цикл while и заведем две переменные для суммы и для текущего числа.
S = 0  # сумма
n = 1  # текущее натуральное число

# задаем условие цикла: пока сумма меньше 500 - цикл работает
while S < 500:
    S += n  # увеличиваем сумму
    n += 1  # увеличиваем шаг на 1 (инкрементируем)
print("Сумма равна: ", S)
print("Потребовалось шагов: ", n)

print()
print("Задание 3.5.4")
# Напишите цикл while, который находит максимальное натуральное число, квадрат которого меньше 1000.
p = 0
while p ** 2 < 1000:
    p += 1
print(p-1)

print()
# Работая с циклом while, нужно быть внимательным,
# ведь если условие остановки будет всегда True, то цикл никогда не остановится.
# Бывают задачи, в которых это полезно, например, вы создадите программу,
# которая будет бесконечно обновлять и отображать время.
# Но часто бесконечный цикл — это ошибка начинающего программиста, который забыл добавить изменение условия цикла.

# # плохо
# n = 1
# while n < 10:  # в данной программе это условие всегда True, цикл будет бесконечным
#     print("Hello World")
# Чтобы остановить выполнение такого скрипта в терминале нужно нажать Ctrl+C.

# Как уже обсуждалось, бывают моменты, когда необходимо специально запустить бесконечный цикл,
# но вопрос, как его потом оставить, не отключая весь скрипт?
# Для этого есть ключевое слово break, которое говорит, что цикл нужно принудительно прервать.
n = 1
while True:
    print("Hello world!")
    n += 1
    if n > 10:  # условие, при достижении которого цикл while будет принудительно завершен
        break

# Особенность использования такого цикла while с условием внутри заключается в том,
# что тело цикла точно выполнится один раз, в отличие от цикла с предусловием.
# Такой цикл ещё называют цикл с постусловием.
print()

print("Задание 3.5.5")
# Напишите бесконечный цикл while с условием выхода внутри цикла, который находит максимальное натуральное число,
# квадрат которого меньше 1000.
n = 1
while True:
    if n**2 > 1000:
        print(n-1)
        break
    n += 1

# ***** Работа с вложенными циклами *****

matrix = [
    [1, 2],
    [3, 4],
    [5, 6]
]
# Такие таблицы ещё называют двумерными списками или двумерными матрицами.
# Двумерная матрица представляет собой обычную таблицу.
# Если одномерная матрица — это список, то двумерная — это список списков.
# Размер данной таблицы 3 х 2, три строки и два столбца.

# Итак, для работы над матрицами нам нужны два цикла, где один вложен в другой.
# Для того, чтобы обойти всю таблицу, нужен один цикл, который будет последовательно перебирать все строки.
# А второй цикл будет перебирать все столбцы для каждой строки.
# То есть обход матрицы будет слева-направо, сверху-вниз.

# Обычно индекс, который отвечает за строки обозначают как i, а за столбцы — j, тогда:
N = 2
M = 3
matrix = [
    [0, 1, 2],
    [3, 4, 5],
]

for i in range(N):
    for j in range(M):
        print(matrix[i][j], end=" ")
    print()  # выполняется после обработки каждой строки
print()

print("Пример 3")
# Условие задачи: Дана двумерная матрица 3x3 (двумерный массив).
# Определить максимум и минимум каждой строки, а также их индексы.
# random_matrix = [
#    [9, 2, 1],
#    [2, 5, 3],
#    [4, 8, 5]
# ]
# Нам нужно найти минимумы в каждой строке и индексы этих минимумов (номера столбцов с минимальным элементом).
# Заведем списки, где мы будем хранить ответ на наш вопрос:
# min_value_rows = []
# min_index_rows = []
# Для начала напишем цикл в котором пройдем по всем строкам матрицы:
# for row in random_matrix:
# Таким образом в переменной row будут строки матрицы (обычные списки),
# в них и выполним поиск минимального и максимального элемента.

# Далее реализуем стандартный алгоритм поиска минимального элемента в списке. Суть этого алгоритма такая:
#     Заведем новую переменную, в которой будем хранить кандидата на звание "минимальный элемент".
#     Для начала пусть кандидатом будет первый элемент списка.
#     В цикле пройдём по всем элементам списка.
#     Сравним этот элемент списка с кандидатом.
#     Если элемент меньше кандидата на звание "минимальный элемент",
#     то наш текущий кандидат не подходит, он не минимальный.
#     Поэтому теперь кандидатом будет этот самый элемент.
#     В конце после прохода по всему списку наш кандидат будет меньше каждого элемента списка,
#     а значит мы нашли минимум.

# Реализуем алгоритм в коде:
# Заведем две переменные:
# min_index = 0
# min_value = row[min_index]
# min_index - индекс кандидата , по алгоритму изначально кандидат - это первый элемент, поэтому индекс 0 .
# min_value - сам кандидат, его значение.
# По алгоритму это первый элемент, можно написать row[0] , а можно написать row[min_index] ,
# потому что в переменной min_index хранится 0.

# Теперь в цикле пройдем по элементам строки row .
# Так как нам требуется еще и индекс, будем перебирать индексы элементов этой строки.
# Индексы списка row это 0, 1 , ... , len(row)-1 .
# Поэтому индексы можно перебрать так:
# for index_col in range(len(row)):

# Теперь сравниваем элемент с индексом index_col  и нашего кандидата в соответствии с алгоритмом:
# if row[index_col] < min_value:

# Если он оказался меньше, то теперь кандидат - это сам текущий элемент:
#
# min_value = row[index_col]
# min_index = index_col

# Поэтому значение кандидата min_value - это сам элемент row[index_col].
# А индекс кандидата - это индекс элемента.
# Теперь после прохода по всему списку кандидатом как раз является минимум списка row .
# Поэтому добавим этого кандидата и его индекс в наши списки с ответами:
# min_value_rows.append(min_value)
# min_index_rows.append(min_index)

# Теперь после прохода в цикле по строкам матрицы выведем наши ответы в консоль:
# print(min_value_rows)
# print(min_index_rows)


random_matrix = [
   [9, 2, 1],
   [2, 5, 3],
   [4, 8, 5]
]
# создаем пустые списки для хранения значений и индексов кандидатов для min, max
min_value_rows = []
min_index_rows = []
max_value_rows = []
max_index_rows = []
# в цикле проходимся по строкам
for row in random_matrix:
    # присваиваем индексу кандидата индекс первого элемента в строке
    min_index = 0
    # присваиваем кандидату значение первого элемента
    min_value = row[min_index]
    # присваиваем индексу кандидата индекс первого элемента в строке
    max_index = 0
    # присваиваем кандидату значение первого элемента
    max_value = row[max_index]
    # внутри строки, циклом проходимся по элементам (столбцам)
    for index_col in range(len(row)):
        # если значение текущего элемента меньше значения кандидата:
        if row[index_col] < min_value:
            # то присваиваем значению кандидата, значение текущего элемента
            min_value = row[index_col]
            # и индекс так же меняется на индекс текущего элемента
            min_index = index_col
        # если значение текущего элемента больше значения кандидата:
        if row[index_col] > max_value:
            # то присваиваем значению кандидата, значение текущего элемента
            max_value = row[index_col]
            # и индекс так же меняется на индекс текущего элемента
            max_index = index_col
    # после прохождения по всем элементам каждой строки, добавляем элемент в список
    min_value_rows.append(min_value)
    min_index_rows.append(min_index)
    max_value_rows.append(max_value)
    max_index_rows.append(max_index)
# выводим элементы с соответствующими сообщениями
print("Минимальные элементы:", min_value_rows)
print("Их индексы:", min_index_rows)
print("Максимальные элементы:", max_value_rows)
print("Их индексы:", max_index_rows)
