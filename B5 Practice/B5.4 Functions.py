# *** Простые функции ***
print("*** Простые функции ***")
# В первую очередь мы должны понимать, от чего зависит работа функции, это послужит аргументами функции.
# А также должны понять, будет ли у функции возвращаемое значение


def linear_solve(a, b):
    return a / b


print(linear_solve(9, 3))

# Модифицируем ее код, чтобы она могла учитывать разное поведение.
def linear_solve(a, b):
    if a:
        return a / b
    else:
        return "нет корней"


print(linear_solve(0, 1))

# Однако и здесь кроется неожиданность.
# Ведь, если и a=0, и b=0, уравнение имеет бесконечное количество корней
# (любое число при умножении на ноль даст ноль).
# А наша программа вернет «Нет корней».
# Так быть не должно. Модифицируем нашу программу еще раз.


def linear_solve(a, b):
    if a:
        return a / b
    elif not a and not b:
        return "Бесконечное множество корней"
    else:
        return "Нет корней"


print(linear_solve(0, 0))
print()

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня
print("Задание 5.4.3")
# Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения.


def discriminant(a, b, c):
    return b**2 - 4*a*c

print()


print("Задание 5.4.4")
# Реализуйте функцию quadratic_solve(a, b, c),
# возвращающую «Нет вещественных корней» в случае отрицательного дискриминанта.


def quadratic_solve(a, b, c):
    if discriminant(a, b, c) < 0:
        return "«Нет вещественных корней»"

print()


print("Задание 5.4.5")
# Модифицируйте функцию quadratic_solve(a, b, c), чтобы она возвращала единственный корень
# при условии нулевого дискриминанта.
def quadratic_solve(a, b, c):
    if discriminant(a, b, c) < 0:
        return "«Нет вещественных корней»"
    elif discriminant(a, b, c) == 0:
        return -b/(2*a)

# И последним этапом нам нужно вернуть сразу два значения. Конечный вид функции будет выглядеть так:
def quadratic_solve(a, b, c):
    if discriminant(a, b, c) < 0:
        return "Нет вещественных корней"
    elif discriminant(a, b, c) == 0:
        return -b / (2 * a)
    else:
        return (-b - discriminant(a,b,c) ** 0.5) / (2 * a), (-b + discriminant(a, b, c) ** 0.5) / (2 * a)

print()
# Представим, что параметры уравнения хранятся в виде списка.
# Такое может быть, если аргументы были получены из консоли.
# L = list(map(float, input("Enter num: ").split()))
# Конечно, можно было бы присвоить новым переменным полученные значения,
# или передавать в аргументы функции, обращаясь через индексы.
# но это не очень, а вот распоковать список = *L - это по питоновски

# Представим, что у нас теперь аргументы хранятся не в виде списка, а в виде словаря.
# M = {'a': 1,
#      'b': 0,
#      'c': -1}
# тогда распоковка идет так: **М



# *** Практический совет: побочные эффекты ***
# В результате работы функции может произойти много чего.
# Иногда это предсказуемо, иногда не очень.
# Однако предсказуемое поведение функций принято проектировать согласно принципам функционального программирования.
# И один из главных принципов рекомендует создавать функции без побочных эффектов (side effects).
# К ним относят:
#         изменение переменных, находящихся на более высоком уровне видимости;
#         ввод/вывод данных;
#         чтение/запись в файл и др.

# Перечисленные побочные эффекты являются основными, но если говорить про них в общем,
# то это такие действия внутри функции, которые каким-либо образом влияют на внешнюю среду.

# *** Рекурсия ***
print("*** Рекурсия ***")
print("Задание 5.4.9")
# Напишите рекурсивную функцию, находящую минимальный элемент списка
# без использование циклов и встроенной функции min().
list_1 = [5, 2, 3, 4, 6]
def min_list(list_):
    if len(list_) == 1:
        return list_[0]
    return list_[0] if list_[0] < min_list(list_[1:]) else min_list(list_[1:])


print(min_list(list_1))
print()

print("Задание 5.4.10")
# Напишите рекурсивную функцию, которая зеркально разворачивает число.
# Предполагается, что число не содержит нули.
num = 224476  # должно быть 321
print(num)


def mirror_num(n):
    s = str(n)
    if len(s) == 1:
        return s
    else:
        return s[-1] + mirror_num(n//10)


print(mirror_num(num))
print()
# от skillFactory
# def mirror(a, res=0):
#     return mirror(a // 10, res*10 + a % 10) if a else res

# Сейчас попробуем реализовать функцию equal(N, S),
# проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то,
# что, если S стала отрицательной, то необходимо сразу вернуть False.
N = 15
S = 30
def equal(N, S, res=0):
    if S < 0:
        return False
    if S != res:
        return equal(N // 10, S, res + N % 10) if N else False
    else:
        return True

print(equal(N,S))

# def equal(N, S):
#     if S < 0:
#         return False
#     if N < 10:
#         return N == S
#     else:
#         return equal(N // 10, S - N % 10)
print()


# *** Генераторы и итераторы ***
print("*** Генераторы и итераторы ***")
# попробуем написать генератор для приближенного вычисления числа e = 2.718.
# Для нахождения числа, удовлетворяющего необходимой точности будем использовать следующий цикл:
# last = 0
# for a in e():
#     if (a - last) < 0.00000001:
#         print(a)
#         break
#     else:
#         last = a

# Для вычисления числа e с определенной точностью можно использовать формулу:
# e_n = (1 + 1/n)**n
# Реализуйте функцию-генератор, каждое значение которого — приближение числа e с некоторым числом n.
# def e():
#     n = 1
#
#     while True:
#         yield (1 + 1 / n) ** n
#         n += 1

# # *** Декораторы ***
# print("*** Декораторы ***")
# # Пусть у нас есть функция, которая должна извлекать из базы данных какую-то информацию.
# # На начальном этапе разработки мы не заботились о том, что это можно делать только при условии,
# # что пользователь программы авторизовался, но сейчас время пришло.
# # Попробуем написать декоратор, который позволяет вызвать функцию,
# # только если она вызывается авторизованным пользователем.
#
# # спрашиваем у пользователя, хочет ли он авторизоваться
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# # в переменную auth сохранили True, если пользователь авторизован.
# auth = yesno == "Y"
#
#
# def is_auth(func):
#     """
#     декоратор, который в случае успешной авторизации выводит соответствующее сообщение и выполняет функцию.
#     Если же пользователь не авторизовался, то также получаем соответствующее сообщение, но уже без вызова самой функции!
#     :param func:
#     :return:
#     """
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь неавторизован. Функция выполнена не будет")
#     return wrapper
#
#
# @is_auth
# def from_db():
#     print("some data from database")
#
#
# from_db()
#
# # Самая главная фишка декораторов в том, что такую обертку можно использовать для многих функций.
# # Если в нашу программу хотим добавить еще одну функцию,
# # для которой мы бы хотели сначала проверить авторизацию пользователя,
# # достаточно всего лишь указать для нее декоратор.
#
#
# @is_auth
# def change_profile():
#     print("Profile has been changed")
#
# print()

print("Задание 5.4.15")
# Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя.
# Все username пользователей хранятся в глобальной области видимости в списке USERS.
# При согласии пользователя на авторизацию ему предлагается ввести username,
# который также хранится в глобальной области видимости.
# Функция должна использовать два декоратора:
# один для проверки авторизации вообще (реализован выше),
# второй — для проверки доступа.

USERS = ['admin', 'guest', 'director', 'root', 'superstar']
yesno = input("""Введите Y, если хотите авторизоваться или N, 
если хотите продолжить работу как анонимный пользователь: """)
auth = yesno == "Y"

if auth:
    username = input("Введите ваш username: ")


def is_auth(function):
    def wrapper():
        if auth:
            print("Пользователь авторизован")
            function()
        else:
            print("Пользователь неавторизован. Функция выполнена не будет")
    return wrapper


def has_access(function):
    def wrapper():
        if username in USERS:
            print(f"Вы вошли как {username}, доступ разрешен.")
            function()
        else:
            print(f"Уважаемый {username}, у вас нет прав доступа!")
    return wrapper


@is_auth
@has_access
def from_db():
    print("some data from database")


from_db()
