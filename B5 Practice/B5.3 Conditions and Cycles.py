# ***** Условия и циклы *****

# логические операторы возвращают не обязательно булевы значения (True или False), а значение одного из операндов.
# Это происходит согласно следующим правилам:

# and: если все операнды являются истинными (ненулевые или непустые), то возвращается последнее истинное значение.
print(1 and "hello" and [False])
# Несмотря на то, что последний операнд похож на False, он является непустым списком, а значит он истинный.

# and: если один из операндов является ложным, то возвращается первый такой операнд.
print(42 and 0 and '' and False)

# or: если один из операндов является истинным, то возвращается первый такой операнд, а остальные игнорируются.
print([] or 3.14 or False)

# or: если все операнды являются ложными, то возвращается последний.
print(0 or '' or False)
print()

print("Задание 5.3.8")
# Программа должна выводить «Обе переменные ложные», если они являются таковыми.
# Дополните условный оператор последним блоком.
a = 1
b = 1
if a and b:
    print("Обе переменные истинные")
    print(a, b)
elif a or b:
    print("Одна из переменных истинная")
    print(a or b)  # печать значения одной переменной, которая является истинной
else:
    print("Обе переменные ложные")
print()

# *** Все или любой? ***
a = 112
print("Задание 5.3.9")
# Напишите алгоритм, реализованный с помощью вложенных условных операторов, который проверяет заданные условия:
# подается число А, мы хотим проверить, является ли оно целым,
# находится ли в определенном промежутке (например от 100 до 999 включительно),
# да еще и делится ли на 2 и 3 одновременно
if type(a) is int:
    if 100 <= a <= 999:
        if a % 2 == 0:
            if a % 3 == 0:
                print("Число удовлетворяет условиям")
print()
print("Задание 5.3.10")
# Напишите тот-же алгоритм, но объединив все условия в одну строку,
# используя логические операторы и операторы сравнения:
if (type(a) is int) and (100 <= a <= 999) and (a % 2 == 0) and (a % 3 == 0):
    print("Число удовлетворяет условиям")

# В Python есть функция all([ ]), которая возвращает True, если все условия,
# переданные в аргумент функции в виде списка, являются истинными.
if all([type(a) == int,
        100 <= a <= 999,
        a % 2 == 0,
        a % 3 == 0]):
    print("Число удовлетворяет условиям")

# Функция all([ ]) возвращает True, если все элементы списка являются истинными.
# А что если нужно, чтобы был хотя бы один истинный?
# Тогда на помощь приходит функция any([ ]).
# Ее синтаксис аналогичен рассмотренному выше примеру c функцией all([ ]).

print("Задание 5.3.11")
# Напишите программу, которая на вход принимает последовательность целых чисел,
# и возвращает True, если все числа ненулевые, и False, если хотя бы одно число равно 0.

num_list = list(map(int, input("Введите числа через пробел: ").split()))
print(all(num_list))
print()

print("Задание 5.3.12")
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True,
# если все числа равны нулю, и False, если найдется хотя бы одно ненулевое число.
# Разрешается использование только логических операторов и функций all([ ]) и any([ ]).
num_list_1 = list(map(int, input("Введите числа через пробел: ").split()))
print(not any(num_list_1))
print()

# *** List comprehension ***
print("*** List comprehension ***")
# Генераторы списков — это специальный синтаксис, определяющий правила создания и заполнения списков.

# В общем виде эта конструкция записывается следующим образом:
# L = [a for a in some_iter_obj if cond]

# Такая запись аналогична следующей:
# L = []
# for a in some_iter_obj:
#     if cond:
#         L.append(a)

# Напишем генератор списков, в котором будут храниться квадраты первых 10 натуральных чисел.
squares = [i**2 for i in range(1, 11)]
print(squares)
# Можно модифицировать этот генератор списков таким образом,
# что в список будут включаться квадраты только от нечетных чисел.
squares_1 = [i**2 for i in range(1, 11) if i % 2 == 1]
print(squares_1)

# Тип элемента, который будет включаться в список может быть любым. Например, можно составить список из кортежей:
list_tuples = [(i, i**2) for i in range(1,11)]
print(list_tuples)

# А используя вложенные генераторы списков можно создать матрицу «одним махом»:
M = [[i+j for j in range(5)] for i in range(5)]
print(M)
print()

print("Задание 5.3.13")
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
multiplication_table = [[i*j for j in range(1, 11)] for i in range(1, 11)]
print(multiplication_table)

# Интересный эффект образуется в сочетании использования генераторов списков и функции input().
# На каждой итерации цикла консоль будет запрашивать данные для ввода и сохранять их в качестве элемента списка.
input_list = [input("enter: ") for i in range(5)]
print(input_list)

input_digit_list = [int(input("enter digital num: ")) for i in range(5)]
print(input_digit_list)
print()

print("Задание 5.3.14")
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент четный,
# и False, если элемент нечетный.
input_digit_list_1 = [int(input("enter digit: ")) % 2 == 0 for i in range(5)]
print(input_digit_list_1)
print()

print("Задание 5.3.15")
# программа выводила True, если есть хотя бы одно четное число.
L = [int(input("=")) % 2 == 0 for i in range(5)]
print(any(L))
print()

print("Задание 5.3.16")
# Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком четности,
# если его результат будет истинным тогда и только тогда,
# когда в списке есть хотя бы один четный и хотя бы один нечетный элемент.

print(any(L) and not all(L))

print()

# *** zip() ***
print("*** zip() ***")
# Рассмотрим еще одну полезную «фичу»,
# которая упрощает работу со списками в циклах (а значит и во вложенных генераторах).

# Допустим у нас есть два списка одинакового размера:
L = [i for i in range(10)]  # 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10, 0, -1)]  # 10 9 8 7 6 5 4 3 2 1
# И нам необходимо создать новый список,
# который будет состоять из произведений соответствующих элементов друг на друга.
# он должен выглядеть так
# 0 9 16 21 24 25 24 21 16 9

# Мы знаем, что элементов в списке 10, поэтому можем пробежаться в цикле по индексам от 0 до 10:
N = []
for i in range(10):
    N.append(L[i]*M[i])
# Такой код является корректным, но не «питоновским».
# Мы знаем, что циклом for можно итерировать сразу списки.
# В Python существует функция zip(), которая позволяет объединить два списка в новый список кортежей,
# каждый из которых будет содержать по одному элементу из каждого списка.
for a, b in zip(L, M):
    print('a=', a, 'b=', b)
# Сначала мы склеили два списка поэлементно, а потом на каждой итерации делали развертку кортежей
# на две переменные — a и b, которые использовали в теле самого цикла.

# Аналогично можно использовать функцию zip() и внутри генераторов списков.
print()

print("Задание 5.3.17")
# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.

N = [a*b for a, b in zip(L, M)]
print(N)
print()

# *** Циклы ***
print("*** Циклы ***")
print("Задание 5.3.18")
# Реализуйте программу, которая сжимает последовательность символов.
# На вход подается последовательность вида: aaabbccccdaa
#
# Необходимо вывести строку, где каждая последовательность из одинаковых символов, идущих подряд,
# заменяется на один символ, и длину этой последовательности (включая последовательности единичной длины).
# Вывод должен выглядеть так: a3b2c4d1a2

print("Задание 5.3.18")
# Реализуйте программу, которая сжимает последовательность символов.
# На вход подается последовательность вида: aaabbccccdaa
#
# Необходимо вывести строку, где каждая последовательность из одинаковых символов, идущих подряд,
# заменяется на один символ, и длину этой последовательности (включая последовательности единичной длины).
# Вывод должен выглядеть так: a3b2c4d1a2

string = 'aaabbccccdaa'
end = len(string) - 1
list_ = []
out_list = []

for symbol in range(len(string)):
    if not list_:
        list_.append(string[symbol])
        out_list.append(string[symbol])
        c = 1
        continue
    elif string[symbol] in list_:
        c += 1
        if symbol == end:
            out_list.append(c)
    elif string[symbol] not in list_:
        out_list.append(c)
        c = 1
        out_list.append(string[symbol])
        list_ = []
        list_.append(string[symbol])
        if symbol == end:
            out_list.append(c)

out_string = ''.join(map(str, out_list))
print(out_string)

# Решение от SkillFactory
text = 'aaabbccccdaa' # получаем строку

last = text[0] # сохраняем первый символ
count = 0 # заводим счетчик
result = '' # и результирующую строку

for c in text:
    if c == last: # если символ совпадает с сохраненным,
        count += 1 # то увеличиваем счетчик
    else:
        result += last + str(count) # иначе - записываем в результат
        last = c # и обновляем сохраненный символ с его счетчиком
        count = 1

result += last + str(count) # и добавляем в результат последний символ
print(result)
